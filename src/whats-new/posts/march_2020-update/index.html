---
tags: whats-new
layout: whats-new-post.njk
permalink: whats-new/march_2020-update/index.html
summary: There have been more than 700 commits to Unison's master branch since
  we last did one of these update posts, so a lot has happened. We've made a lot
  of bug-fixes and improvements to the ergonomics of Unison--too many to list
  them all here. Here are some highlights.
featuredImage: /assets/thing7.svg
categories:
  - news
authors:
  - runar-bjarnason
  - aryai-irani
date: 2020-03-12T00:00:00.000Z
title: First class documentation with live examples, rethinking the pull
  request, a new runtime, and more
---

{% raw %}
<article class="unison-doc"><section><p></p><section><p><span class="span"><span class="word">There have been more than 700 commits to Unison's master branch since we last did one of these update posts, so a lot has happened. We've made a lot of bug-fixes and improvements to the ergonomics of Unison--too many to list them all here. Here are some highlights.</span></span></p><section><h2 id="support-for-first-class-api-docs-with-live-code-examples"><span class="span"><span class="word">Support for first-class API docs with live code examples</span></span></h2><p><span class="span"><span class="word">You can now write documentation for your Unison libraries, and link the docs to the definitions in your codebase. What's more, documentation is first-class, so it's just Unison code! This means:</span></span></p><ul><li><span class="span"><span class="word">You can access documentation from Unison code and compute with it.</span></span></li><li><span class="span"><span class="word">Code snippets and examples in your docs are not just text, but "live" code that typechecks.</span></span></li><li><span class="span"><span class="word">Such code doesn't get out of date. When you refactor or update code that's referenced in documentation, the Unison Codebase Manager automatically updates the docs.</span></span></li></ul><p><span class="span"><span class="word">For more information about this, see</span><span class="group"><span class="join"><a href="https://www.unisonweb.org/docs/documentation" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Documenting Unison code</span></span></a><span class="word">.</span></span></span></span></p></section><section><h2 id="new-documentation-topics-on-unisons-abilities-system-and-its-testing-library"><span class="span"><span class="word">New documentation topics on Unison's abilities system and its testing library</span></span></h2><p><span class="span"><span class="word">We added some new documentation topics! Firstly, we documented Unison's type system feature called</span><a href="/docs/abilities" class="named-link" rel="noopener" target="_self"><span class="word">abilities</span></a><span class="word">(often called</span><span class="italic"><span class="span"><span class="word">algebraic effects</span></span></span><span class="word">in the literature), a powerful yet easy-to-use feature that can express asynchronous programming, stream processing, coroutines, nondeterminism, and more. See</span><span class="group"><span class="join"><a href="/docs/abilities" class="named-link" rel="noopener" target="_self"><span class="span"><span class="word">the docs on abilities</span></span></a><span class="word">.</span></span></span><span class="word">As a quick example, here's an implementation of Python-style generators in a few lines of Unison code:</span></span></p><div class="rich source code unison"><pre><code><span class="word">ability Stream e where
  emit : e -&gt; ()

-- Emit all natural numbers starting from `n`
Stream.from : Nat -&gt;{Stream Nat} ()
Stream.from n =
  emit n
  Stream.from (n + 1)</span></code></pre></div><p><span class="span"><span class="word">See</span><a href="/docs/abilities" class="named-link" rel="noopener" target="_self"><span class="span"><span class="word">the abilities tutorial</span></span></a><span class="word">for more.</span></span></p><p><span class="span"><span class="word">We also added</span><span class="group"><span class="join"><a href="/docs/testing" class="named-link" rel="noopener" target="_self"><span class="span"><span class="word">better documentation on how to write tests in Unison</span></span></a><span class="word">.</span></span></span><span class="word">For a while now, Unison's</span><a href="https://github.com/unisonweb/base" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">base libraries</span></span></a><span class="word">have come with a nice (but not well documented) library for testing, which supports traditional unit tests and programmatically generated test cases. Here's a quick example:</span></span></p><div class="rich source code unison"><pre><code><span class="word">test&gt; myTest = check (1 + 1 == 2)

test&gt; Nat.tests.addition = runs 1000 'let
  x = natIn 0 100
  y = natIn 100 200
  expect ((x+y) == (y+x))</span></code></pre></div><p><span class="span"><span class="word">See</span><a href="/docs/testing" class="named-link" rel="noopener" target="_self"><span class="span"><span class="word">the documentation for how to write tests in Unison</span></span></a><span class="word">to learn more.</span></span></p></section><section><h2 id="a-workflow-for-making-pull-requests-against-unison-repos"><span class="span"><span class="word">A workflow for making pull requests against Unison repos</span></span></h2><p><span class="span"><span class="word">This is still a work in progress, but we have a fairly straightforward workflow that you can use to make "pull requests" against Unison repos. The usual pull request review process involves navigating large textual diffs, using a tool that has little understanding of your code. Unison has a semantic understanding of changes that are made to a namespace, and can report things like "this function was changed" or "this definition was moved from here to there" rather than "these 46 lines in this file are now different, as are these other 74 lines in this other file". Also, by storing the Unison codebase as serialized abstract syntax trees, we avoid merge conflicts and diffs due to things like formatting.</span></span></p><p><span class="span"><span class="word">Because of this more semantic understanding, the PR review process can also be more random-access, where one can hop around through semantically meaningful parts of the change rather than scrolling through large textual diffs.</span></span></p><p><span class="span"><span class="word">Though we still call them "pull requests" and though Unison repos are hostable on GitHub, we cannot actually use the GitHub pull request mechanism. Or at least, that would not be a nice experience. Instead, Unison has its own kind of pull request.</span></span></p><p><span class="span"><span class="word">Let's say we've forked the</span><a href="https://github.com/unisonweb/base" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Unison Base library</span></span></a><span class="word">to</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">https://github.com/me/mybase</span></code></span><span class="word">,</span></span></span><span class="word">and we've added a new function</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Char.toText</span></code></span><span class="word">that we would like to have merged back to</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">unisonweb/base</span></code></span><span class="word">.</span></span></span><span class="word">We can create a Unison pull request from the Unison Codebase Manager, with</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">pr.create</span></code></span><span class="word">:</span></span></span></span></p><div class="rich source code ucm"><pre><code><span class="word">.&gt; pr.create https://github.com/unisonweb/base https://github.com/me/mybase

  The changes summarized below are available for you to review, using the
  following command:

    pr.load https://github.com/unisonweb/base https://github.com/me/mybase

  Added definitions:

     Char.toText                           : Char -&gt; Text</span></code></pre></div><p><span class="span"><span class="word">We take the output of this command and send it to the recipient of our pull request. In this case, we could for example paste it into a new GitHub issue opened against</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">unisonweb/base</span></code></span><span class="word">.</span></span></span><span class="word">A maintainer of that repo can then run the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">pr.load</span></code></span><span class="word">command in their Codebase Manager:</span></span></p><div class="rich source code ucm"><pre><code><span class="word">.&gt; pr.load https://github.com/unisonweb/base https://github.com/me/mybase pr1

  I checked out https://github.com/unisonweb/base to pr1.base.
  I checked out https://github.com/me/mybase to pr1.head.

  The merged result is in pr1.merged.
  Use `diff.namespace pr1.base pr1.merged` to see what's been updated.
  Use `todo merged.patch pr1.merged` to see what work is remaining for the merge.
  Use `push https://github.com/unisonweb/base pr1.merged` to push the changes.</span></code></pre></div><p><span class="span"><span class="word">Following the instructions in the output of</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">pr.load</span></code></span><span class="word">,</span></span></span><span class="word">the maintainer of</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unisonweb/base</span></code></span><span class="word">can audit our changes and push them to their repo on GitHub.</span></span></p><p><span class="span"><span class="word">There will be a more detailed tutorial on this feature of UCM once it's a little bit more polished.</span></span></p></section><section><h2 id="an-improved-process-for-refactoring-data-types"><span class="span"><span class="word">An improved process for refactoring data types</span></span></h2><p><span class="span"><span class="word">We've vastly improved the experience of updating or refactoring types. In Unison, when you make a modification to a data type, you actually create a new type and any existing code needs to be made to use your new type instead of the old one. With the improvements we've made, you just need to issue an</span><span class="rich source inline-code"><code class="inline-code"><span class="word">update</span></code></span><span class="word">command in UCM, and it will try to update any code that depends on the changed data type.</span></span></p><p><span class="span"><span class="word">Sometimes this will result in code that doesn't typecheck, and Unison will let you know if that's the case so you can make the changes manually. To this end, we've also added commands that give you somewhat precise control of term and type replacements,</span><span class="rich source inline-code"><code class="inline-code"><span class="word">replace.term</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">replace.type</span></code></span><span class="word">.</span></span></span><span class="word">These let you create patches that (when applied) replace all appearances of one term or type in a namespace with another.</span></span></p></section><section><h2 id="a-number-of-syntax-changes"><span class="span"><span class="word">A number of syntax changes</span></span></h2><p><span class="span"><span class="word">We've made some changes to Unison's surface syntax, hoping to make the language more ergonomic. Kudos go to Aaron Novstrup who contributed each of these improvements. ðŸ™Œ A cool thing about Unison is that we can change the syntax without breaking anyone's existing code! When you update to the latest version of Unison, it will simply start rendering your code using the new syntax.</span></span></p><p><span class="span"><span class="word">Here are three major syntax changes:</span></span></p><section><h3 id="handler-blocks"><span class="span"><span class="word">Handler blocks</span></span></h3><p><span class="span"><span class="word">Where you used to write</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">handle h in x</span></code></span><span class="word">,</span></span></span><span class="word">such that</span><span class="rich source inline-code"><code class="inline-code"><span class="word">h</span></code></span><span class="word">is an</span><a href="https://www.unisonweb.org/docs/abilities" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">ability handler</span></span></a><span class="word">and</span><span class="rich source inline-code"><code class="inline-code"><span class="word">x</span></code></span><span class="word">is some code that needs the abilities handled by</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">h</span></code></span><span class="word">,</span></span></span><span class="word">you now write</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">handle x with h</span></code></span><span class="word">.</span></span></span><span class="word">We think this makes the code easier to read and write, since the logic (the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">handle</span></code></span><span class="word">block) comes before the implementation specifics (the handler). Now it looks rather like</span><span class="rich source inline-code"><code class="inline-code"><span class="word">try</span></code></span><span class="word">/</span><span class="rich source inline-code"><code class="inline-code"><span class="word">catch</span></code></span><span class="word">in other languages:</span></span></p><div class="rich source code unison"><pre><code><span class="word">handle
  doOneThing
  doAnotherThing
with
  theHandler</span></code></pre></div><p><span class="span"><span class="word">As a bonus, we're able to get rid of the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">in</span></code></span><span class="word">keyword, freeing that name up for use as an ordinary identifier.</span></span></p></section><section><h3 id="match-with-instead-of-case-of"><span class="span"><span class="word">Match-with instead of case-of</span></span></h3><p><span class="span"><span class="word">Pattern matching gets a facelift as well. Where you used to write</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">case x of ...</span></code></span><span class="word">,</span></span></span><span class="word">you now write</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">match x with ...</span></code></span><span class="word">.</span></span></span><span class="word">For example:</span></span></p><div class="rich source code unison"><pre><code><span class="word">match List.head xs with
  Some x -&gt; "Hello, " ++ x
  None -&gt; "Goodbye"</span></code></pre></div></section><section><h3 id="lambda-case-syntax"><span class="span"><span class="word">Lambda-case syntax</span></span></h3><p><span class="span"><span class="word">When writing a lambda literal that pattern matches on its argument, normally you would write:</span></span></p><div class="rich source code unison"><pre><code><span class="word">x -&gt; match x with ...</span></code></pre></div><p><span class="span"><span class="word">But if you don't care to give the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">x</span></code></span><span class="word">argument a name, now you can instead just write:</span></span></p><div class="rich source code unison"><pre><code><span class="word">cases ...</span></code></pre></div><p><span class="span"><span class="word">This looks especially nice in ability handlers:</span></span></p><div class="rich source code unison"><pre><code><span class="word">handle
  doOneThing
  doAnotherThing
with cases
  { x } -&gt; x
  { Store.get   -&gt; k } -&gt; ...
  { Store.put v -&gt; k } -&gt; ...</span></code></pre></div></section></section><section><h2 id="use-any-unambiguous-name-suffix-to-identify-definitions"><span class="span"><span class="word">Use any unambiguous name suffix to identify definitions</span></span></h2><p><span class="span"><span class="word">This change massively cuts down on import boilerplate. For example, you can use</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Optional</span></code></span><span class="word">unqualified, without a</span><span class="rich source inline-code"><code class="inline-code"><span class="word">use</span></code></span><span class="word">clause to import it, as long as there's no other</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Optional</span></code></span><span class="word">type in your tree.</span></span></p><p><span class="span"><span class="word">If you have two</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Optional</span></code></span><span class="word">types,</span><span class="rich source inline-code"><code class="inline-code"><span class="word">.foo.bar.Optional</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">.my.cool.Optional</span></code></span><span class="word">,</span></span></span><span class="word">then</span><span class="rich source inline-code"><code class="inline-code"><span class="word">cool.Optional</span></code></span><span class="word">is a suffix of name segments that uniquely identifies the latter type, and can be used without any imports.</span></span></p><p><span class="span"><span class="word">Notably, you no longer have to use patterns qualified with their data type. So whereas before you might have had this:</span></span></p><div class="rich source code unison"><pre><code><span class="word">use .base Optional Text

myFunction : Optional Text -&gt; Text
myFunction x = match x with
  Optional.Some x -&gt; "Hello, " ++ x
  Optional.None -&gt; "Goodbye"</span></code></pre></div><p><span class="span"><span class="word">you can now just say:</span></span></p><div class="rich source code unison"><pre><code><span class="word">myFunction : Optional Text -&gt; Text
  Some x -&gt; "Hello, " ++ x
  None -&gt; "Goodbye"</span></code></pre></div><p><span class="span"><span class="word">More generally, you can now refer to a type or term without imports using any suffix of name segments that has just one referent.</span></span></p></section><section><h2 id="builtins-for-crashing-unison-programs"><span class="span"><span class="word">Builtins for crashing Unison programs</span></span></h2><p><span class="span"><span class="word">We added two builtins,</span><span class="rich source inline-code"><code class="inline-code"><span class="word">bug</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">todo</span></code></span><span class="word">,</span></span></span><span class="word">which simply crash your program with an error. (A shoutout to Noah Haasis for contributing both of these! ðŸŽ‰)</span></span></p><p><span class="span"><span class="word">The</span><span class="rich source inline-code"><code class="inline-code"><span class="word">todo</span></code></span><span class="word">builtin is handy for when you've only partially implemented something but you want to try out the partial implementation anyway:</span></span></p><div class="rich source code unison"><pre><code><span class="word">myFunction x = match x with
  Some x -&gt; "Hello, " ++ x
  None -&gt; todo "Handle the None case"</span></code></pre></div><p><span class="span"><span class="word">The</span><span class="rich source inline-code"><code class="inline-code"><span class="word">bug</span></code></span><span class="word">builtin is for implementing assertions and sanity checks, a way to quickly crash if you hit a case that should be impossible if your code were correct. For example:</span></span></p><div class="rich source code unison"><pre><code><span class="word">...
tree' = rebalance tree
if isBalanced tree' then
  tree'
else
  bug ("Tree unbalanced after rebalancing!", tree')</span></code></pre></div><p><span class="span"><span class="word">You can pass any value at all to</span><span class="rich source inline-code"><code class="inline-code"><span class="word">bug</span></code></span><span class="word">or</span><span class="rich source inline-code"><code class="inline-code"><span class="word">todo</span></code></span><span class="word">and it will be nicely formatted by Unison, using the pretty-printing code developed by contributor Chris Gibbs. A common idiom is just to give it a tuple with one element being the description and the other elements being a list of values that you want to be able to see if</span><span class="rich source inline-code"><code class="inline-code"><span class="word">bug</span></code></span><span class="word">or</span><span class="rich source inline-code"><code class="inline-code"><span class="word">todo</span></code></span><span class="word">call is ever hit in running code.</span></span></p></section><section><h2 id="whats-next"><span class="span"><span class="word">What's next?</span></span></h2><p><span class="span"><span class="word">We're going to keep polishing the pull-request workflow to make it nicer to use and will be opening up</span><a href="https://github.com/unisonweb/base" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">the Unison base libraries</span></span></a><span class="word">to new contributors very soon.</span></span></p><p><span class="span"><span class="word">Also exciting is that Dan Doel has started implementation on a new runtime for Unison which is going to be a lot faster than what we have now and sets us up to write a proper JIT for Unison. We'd like Unison to be both great to program in and also insanely fast. Unlike the current runtime, Dan's work is the start of a more traditional JIT compiler pipeline, where the code goes through several initial stages of transformations before being converted to an intermediate representation (IR) where various optimizations can be expressed before moving to code generation. The current code generation process Dan's working on goes to a low level representation that gets interpreted efficiently, but the endgame would be to go to something like LLVM.</span></span></p><p><span class="span"><span class="word">We might do a more in-depth technical post on the new runtime work. In particular, going to LLVM has interesting challenges due to Unison's</span><a href="/docs/abilities" class="named-link" rel="noopener" target="_self"><span class="span"><span class="word">ability system</span></span></a><span class="word">which needs to capture and manipulate continuations at runtime.</span></span></p><p><span class="span"><span class="word">The new runtime should land in the next couple of months, along with some new builtin functions we'll need to start building out Unison's distributed computing libraries.</span></span></p><p><span class="span"><span class="word">We still have a lot more work to do, but things are coming together!</span></span></p></section></section></section><div class="tooltips" style="display: none;"></div></article>
{% endraw %}
